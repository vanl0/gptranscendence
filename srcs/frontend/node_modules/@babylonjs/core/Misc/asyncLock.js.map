{"version":3,"file":"asyncLock.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/asyncLock.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,SAAS;IAAtB;QACY,sBAAiB,GAAkB,OAAO,CAAC,OAAO,EAAE,CAAC;IA4DjE,CAAC;IA1DG;;;;;OAKG;IACH,2FAA2F;IACpF,SAAS,CAAI,IAA0B,EAAE,MAAoB;QAChE,MAAM,EAAE,cAAc,EAAE,CAAC;QAEzB,MAAM,WAAW,GAAG,MAAM;YACtB,CAAC,CAAC,qEAAqE;gBACrE,GAAG,EAAE;oBACD,MAAM,CAAC,cAAc,EAAE,CAAC;oBACxB,OAAO,IAAI,EAAE,CAAC;gBAClB,CAAC;YACH,CAAC,CAAC,IAAI,CAAC;QAEX,0CAA0C;QAC1C,MAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9D,oKAAoK;QACpK,IAAI,CAAC,iBAAiB,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;YACnD,0CAA0C;YAC1C,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,CAAC;QAChD,CAAC,CAAC,CAAC;QACH,OAAO,YAAY,CAAC;IACxB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAI,IAA0B,EAAE,KAAkB,EAAE,MAAoB;QACjG,MAAM,EAAE,cAAc,EAAE,CAAC;QAEzB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACrB,OAAO,MAAM,IAAI,EAAE,CAAC;QACxB,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAK,CAAC;QACnC,IAAI,aAAa,GAAG,CAAC,CAAC;QAEtB,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACvB,IAAI,CAAC,SAAS,CAAC,KAAK,IAAI,EAAE;gBACtB,aAAa,EAAE,CAAC;gBAChB,IAAI,aAAa,KAAK,KAAK,CAAC,MAAM,EAAE,CAAC;oBACjC,QAAQ,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;gBACnC,CAAC;gBACD,OAAO,MAAM,QAAQ,CAAC,OAAO,CAAC;gBAC9B,0CAA0C;YAC9C,CAAC,EAAE,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC;QAED,OAAO,MAAM,QAAQ,CAAC,OAAO,CAAC;IAClC,CAAC;CACJ","sourcesContent":["import { Deferred } from \"./deferred\";\r\n\r\n/**\r\n * Provides a simple way of creating the rough equivalent of an async critical section.\r\n *\r\n * @example\r\n * ```typescript\r\n * const myLock = new AsyncLock();\r\n *\r\n * private async MyFuncAsync(): Promise<void> {\r\n *   await myLock.lockAsync(async () => {\r\n *     await operation1Async();\r\n *     await operation2Async();\r\n *   });\r\n * }\r\n * ```\r\n */\r\nexport class AsyncLock {\r\n    private _currentOperation: Promise<void> = Promise.resolve();\r\n\r\n    /**\r\n     * Executes the provided function when the lock is acquired (e.g. when the previous operation finishes).\r\n     * @param func The function to execute.\r\n     * @param signal An optional signal that can be used to abort the operation.\r\n     * @returns A promise that resolves when the func finishes executing.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public lockAsync<T>(func: () => T | Promise<T>, signal?: AbortSignal): Promise<T> {\r\n        signal?.throwIfAborted();\r\n\r\n        const wrappedFunc = signal\r\n            ? // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n              () => {\r\n                  signal.throwIfAborted();\r\n                  return func();\r\n              }\r\n            : func;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        const newOperation = this._currentOperation.then(wrappedFunc);\r\n        // NOTE: It would be simpler to just hold a Promise<unknown>, but this class should not prevent an object held by the returned promise from being garbage collected.\r\n        this._currentOperation = new Promise<void>((resolve) => {\r\n            // eslint-disable-next-line github/no-then\r\n            newOperation.then(() => resolve(), resolve);\r\n        });\r\n        return newOperation;\r\n    }\r\n\r\n    /**\r\n     * Executes the provided function when all the specified locks are acquired.\r\n     * @param func The function to execute.\r\n     * @param locks The locks to acquire.\r\n     * @param signal An optional signal that can be used to abort the operation.\r\n     * @returns A promise that resolves when the func finishes executing.\r\n     */\r\n    public static async LockAsync<T>(func: () => T | Promise<T>, locks: AsyncLock[], signal?: AbortSignal): Promise<T> {\r\n        signal?.throwIfAborted();\r\n\r\n        if (locks.length === 0) {\r\n            return await func();\r\n        }\r\n\r\n        const deferred = new Deferred<T>();\r\n        let acquiredLocks = 0;\r\n\r\n        for (const lock of locks) {\r\n            lock.lockAsync(async () => {\r\n                acquiredLocks++;\r\n                if (acquiredLocks === locks.length) {\r\n                    deferred.resolve(await func());\r\n                }\r\n                return await deferred.promise;\r\n                // eslint-disable-next-line github/no-then\r\n            }, signal).catch((e) => deferred.reject(e));\r\n        }\r\n\r\n        return await deferred.promise;\r\n    }\r\n}\r\n"]}