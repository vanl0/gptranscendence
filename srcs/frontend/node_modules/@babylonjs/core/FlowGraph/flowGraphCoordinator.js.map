{"version":3,"file":"flowGraphCoordinator.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraphCoordinator.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,UAAU,EAAE,8BAA6B;AAElD,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAIxC,OAAO,EAAE,MAAM,EAAE,0BAAyB;AAgC1C;;;;;GAKG;AACH,MAAM,OAAO,oBAAoB;IAmC7B;IACI;;OAEG;IACI,MAA0C;QAA1C,WAAM,GAAN,MAAM,CAAoC;QArBrD;;;WAGG;QACI,gCAA2B,GAAY,IAAI,CAAC;QAElC,gBAAW,GAAgB,EAAE,CAAC;QAEvC,qBAAgB,GAAiC,IAAI,GAAG,EAAE,CAAC;QAE3D,2BAAsB,GAAwB,IAAI,GAAG,EAAE,CAAC;QAIxD,wBAAmB,GAAmD,EAAE,CAAC;QACzE,mBAAc,GAAW,CAAC,CAAC;QAQ/B,0EAA0E;QAC1E,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,CAAC,GAAG,EAAE;YACnE,IAAI,CAAC,OAAO,EAAE,CAAC;QACnB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,GAAG,CAAC,GAAG,EAAE;YAC/E,oEAAoE;YACpE,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,CAAC;YACpC,wFAAwF;YACxF,MAAM,kBAAkB,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC7D,IAAI,kBAAkB,CAAC,MAAM,EAAE,CAAC;gBAC5B,4DAA4D;gBAC5D,KAAK,MAAM,KAAK,IAAI,kBAAkB,EAAE,CAAC;oBACrC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBACpD,kCAAkC;oBAClC,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,KAAK,KAAK,CAAC,QAAQ,CAAC,CAAC;oBACvF,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;wBACf,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;oBAC9C,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,8DAA8D;QAC9D,MAAM,YAAY,GAAG,oBAAoB,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACzF,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACI,WAAW;QACd,MAAM,KAAK,GAAG,IAAI,SAAS,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;QAC7E,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC7B,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;OAGG;IACI,WAAW,CAAC,KAAgB;QAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC9C,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;YACf,KAAK,CAAC,OAAO,EAAE,CAAC;YAChB,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACtC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,KAAK;QACR,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACnC,KAAK,CAAC,KAAK,EAAE,CAAC;QAClB,CAAC;IACL,CAAC;IAED;;OAEG;IACI,OAAO;QACV,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACnC,KAAK,CAAC,OAAO,EAAE,CAAC;QACpB,CAAC;QACD,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QAC5B,IAAI,CAAC,gBAAgB,EAAE,MAAM,EAAE,CAAC;QAChC,IAAI,CAAC,uBAAuB,EAAE,MAAM,EAAE,CAAC;QAEvC,mEAAmE;QACnE,MAAM,YAAY,GAAG,oBAAoB,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACzF,MAAM,KAAK,GAAG,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzC,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;YACf,YAAY,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAClC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACI,SAAS,CAAC,mBAAwB,EAAE,sBAAoF;QAC3H,mBAAmB,CAAC,WAAW,GAAG,EAAE,CAAC;QACrC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACnC,MAAM,eAAe,GAAG,EAAE,CAAC;YAC3B,KAAK,CAAC,SAAS,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC;YACzD,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC1D,CAAC;QACD,mBAAmB,CAAC,2BAA2B,GAAG,IAAI,CAAC,2BAA2B,CAAC;IACvF,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACjB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,EAAU;QACtC,IAAI,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/C,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,oGAAoG;YACpG,UAAU,GAAG,IAAI,UAAU,EAAM,mBAAmB,CAAC,CAAC;YACtD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QAC9C,CAAC;QACD,OAAO,UAAU,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACI,iBAAiB,CAAC,EAAU,EAAE,IAAS,EAAE,QAAiB,CAAC,IAAI,CAAC,2BAA2B;QAC9F,IAAI,KAAK,EAAE,CAAC;YACR,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;YAC7E,OAAO;QACX,CAAC;QACD,yDAAyD;QACzD,IAAI,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;YACtC,MAAM,KAAK,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAE,CAAC;YACnD,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;YAC/C,IAAI,KAAK,IAAI,oBAAoB,CAAC,6BAA6B,EAAE,CAAC;gBAC9D,IAAI,KAAK,KAAK,oBAAoB,CAAC,6BAA6B,EAAE,CAAC;oBAC/D,MAAM,CAAC,IAAI,CAAC,uDAAuD,EAAE,IAAI,CAAC,CAAC;gBAC/E,CAAC;gBACD,OAAO;YACX,CAAC;QACL,CAAC;aAAM,CAAC;YACJ,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QAC3C,CAAC;QACD,MAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACjD,IAAI,UAAU,EAAE,CAAC;YACb,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QACrC,CAAC;IACL,CAAC;;AAvLD;;;;GAIG;AACW,qCAAgB,GAAW,EAAE,AAAb,CAAc;AAE5C;;GAEG;AACW,kDAA6B,GAAW,EAAE,AAAb,CAAc;AACzD;;;GAGG;AACoB,sCAAiB,GAAuC,IAAI,GAAG,EAAE,AAAhD,CAAiD","sourcesContent":["import type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraph } from \"./flowGraph\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Parameters used to create a flow graph engine.\r\n */\r\nexport interface IFlowGraphCoordinatorConfiguration {\r\n    /**\r\n     * The scene that the flow graph engine belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n\r\n/**\r\n * Parameters used to parse a flow graph coordinator.\r\n */\r\nexport interface IFlowGraphCoordinatorParseOptions {\r\n    /**\r\n     * A function that will be called to parse the value of a property.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\r\n    /**\r\n     * The scene that the flow graph coordinator belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n/**\r\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\r\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\r\n * This is the entry point for the flow graph system.\r\n * @experimental This class is still in development and is subject to change.\r\n */\r\nexport class FlowGraphCoordinator {\r\n    /**\r\n     * The maximum number of events per type.\r\n     * This is used to limit the number of events that can be created in a single scene.\r\n     * This is to prevent infinite loops.\r\n     */\r\n    public static MaxEventsPerType: number = 30;\r\n\r\n    /**\r\n     * The maximum number of execution of a specific event in a single frame.\r\n     */\r\n    public static MaxEventTypeExecutionPerFrame: number = 30;\r\n    /**\r\n     * @internal\r\n     * A list of all the coordinators per scene. Will be used by the inspector\r\n     */\r\n    public static readonly SceneCoordinators: Map<Scene, FlowGraphCoordinator[]> = new Map();\r\n\r\n    /**\r\n     * When set to true (default) custom events will be dispatched synchronously.\r\n     * This means that the events will be dispatched immediately when they are triggered.\r\n     */\r\n    public dispatchEventsSynchronously: boolean = true;\r\n\r\n    private readonly _flowGraphs: FlowGraph[] = [];\r\n\r\n    private _customEventsMap: Map<string, Observable<any>> = new Map();\r\n\r\n    private _eventExecutionCounter: Map<string, number> = new Map();\r\n\r\n    private _disposeObserver: Observer<Scene>;\r\n    private _onBeforeRenderObserver: Observer<Scene>;\r\n    private _executeOnNextFrame: { id: string; data?: any; uniqueId: number }[] = [];\r\n    private _eventUniqueId: number = 0;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config: IFlowGraphCoordinatorConfiguration\r\n    ) {\r\n        // When the scene is disposed, dispose all graphs currently running on it.\r\n        this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {\r\n            // Reset the event execution counter at the beginning of each frame.\r\n            this._eventExecutionCounter.clear();\r\n            // duplicate the _executeOnNextFrame array to avoid modifying it while iterating over it\r\n            const executeOnNextFrame = this._executeOnNextFrame.slice(0);\r\n            if (executeOnNextFrame.length) {\r\n                // Execute the events that were triggered on the next frame.\r\n                for (const event of executeOnNextFrame) {\r\n                    this.notifyCustomEvent(event.id, event.data, false);\r\n                    // remove the event from the array\r\n                    const index = this._executeOnNextFrame.findIndex((e) => e.uniqueId === event.uniqueId);\r\n                    if (index !== -1) {\r\n                        this._executeOnNextFrame.splice(index, 1);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Add itself to the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        coordinators.push(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new flow graph and adds it to the list of existing flow graphs\r\n     * @returns a new flow graph\r\n     */\r\n    public createGraph(): FlowGraph {\r\n        const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });\r\n        this._flowGraphs.push(graph);\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * Removes a flow graph from the list of existing flow graphs and disposes it\r\n     * @param graph the graph to remove\r\n     */\r\n    public removeGraph(graph: FlowGraph) {\r\n        const index = this._flowGraphs.indexOf(graph);\r\n        if (index !== -1) {\r\n            graph.dispose();\r\n            this._flowGraphs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts all graphs\r\n     */\r\n    public start() {\r\n        for (const graph of this._flowGraphs) {\r\n            graph.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes all graphs\r\n     */\r\n    public dispose() {\r\n        for (const graph of this._flowGraphs) {\r\n            graph.dispose();\r\n        }\r\n        this._flowGraphs.length = 0;\r\n        this._disposeObserver?.remove();\r\n        this._onBeforeRenderObserver?.remove();\r\n\r\n        // Remove itself from the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        const index = coordinators.indexOf(this);\r\n        if (index !== -1) {\r\n            coordinators.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this coordinator to a JSON object.\r\n     * @param serializationObject the object to serialize to\r\n     * @param valueSerializeFunction the function to use to serialize the value\r\n     */\r\n    public serialize(serializationObject: any, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject._flowGraphs = [];\r\n        for (const graph of this._flowGraphs) {\r\n            const serializedGraph = {};\r\n            graph.serialize(serializedGraph, valueSerializeFunction);\r\n            serializationObject._flowGraphs.push(serializedGraph);\r\n        }\r\n        serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of flow graphs\r\n     */\r\n    public get flowGraphs() {\r\n        return this._flowGraphs;\r\n    }\r\n\r\n    /**\r\n     * Get an observable that will be notified when the event with the given id is fired.\r\n     * @param id the id of the event\r\n     * @returns the observable for the event\r\n     */\r\n    public getCustomEventObservable(id: string): Observable<any> {\r\n        let observable = this._customEventsMap.get(id);\r\n        if (!observable) {\r\n            // receive event is initialized before scene start, so no need to notify if triggered. but possible!\r\n            observable = new Observable<any>(/*undefined, true*/);\r\n            this._customEventsMap.set(id, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Notifies the observable for the given event id with the given data.\r\n     * @param id the id of the event\r\n     * @param data the data to send with the event\r\n     * @param async if true, the event will be dispatched asynchronously\r\n     */\r\n    public notifyCustomEvent(id: string, data: any, async: boolean = !this.dispatchEventsSynchronously) {\r\n        if (async) {\r\n            this._executeOnNextFrame.push({ id, data, uniqueId: this._eventUniqueId++ });\r\n            return;\r\n        }\r\n        // check if we are not exceeding the max number of events\r\n        if (this._eventExecutionCounter.has(id)) {\r\n            const count = this._eventExecutionCounter.get(id)!;\r\n            this._eventExecutionCounter.set(id, count + 1);\r\n            if (count >= FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                if (count === FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                    Logger.Warn(`FlowGraphCoordinator: Too many executions of event \"${id}\".`);\r\n                }\r\n                return;\r\n            }\r\n        } else {\r\n            this._eventExecutionCounter.set(id, 1);\r\n        }\r\n        const observable = this._customEventsMap.get(id);\r\n        if (observable) {\r\n            observable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n"]}