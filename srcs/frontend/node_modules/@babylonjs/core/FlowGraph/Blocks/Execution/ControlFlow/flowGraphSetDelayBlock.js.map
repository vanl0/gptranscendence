{"version":3,"file":"flowGraphSetDelayBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport { RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\nimport { Logger } from \"../../../../Misc/logger\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\n\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    /**\n     * The maximum number of parallel delays that can be set per node.\n     */\n    public static MaxParallelDelayCount = 100;\n    /**\n     * Input signal: If activated the delayed activations set by this block will be canceled.\n     */\n    public readonly cancel: FlowGraphSignalConnection;\n\n    /**\n     * Input connection: The duration of the delay in seconds.\n     */\n    public readonly duration: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: The last delay index that was set.\n     */\n    public readonly lastDelayIndex: FlowGraphDataConnection<FlowGraphInteger>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\n    }\n\n    public override _preparePendingTasks(context: FlowGraphContext): void {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n\n        // active delays are global to the context\n        const activeDelays: number = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex: number = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const scene = context.configuration.scene;\n        const timer: AdvancedTimer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n        this._updateGlobalTimers(context);\n    }\n\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);\n        this._updateGlobalTimers(context);\n    }\n\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        } else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetDelay;\n    }\n\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        } else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n\n        this._updateGlobalTimers(context);\n    }\n\n    private _updateGlobalTimers(context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const globalTimers = context._getGlobalContextVariable(\"pendingDelays\", [] as AdvancedTimer[]);\n        // there should NEVER be the same index in the global and local timers, unless they are equal\n        for (let i = 0; i < timers.length; i++) {\n            if (!timers[i]) {\n                continue;\n            }\n            const timer = timers[i];\n            if (globalTimers[i] && globalTimers[i] !== timer) {\n                Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n            } else {\n                globalTimers[i] = timer;\n            }\n        }\n        context._setGlobalContextVariable(\"pendingDelays\", globalTimers);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetDelay, FlowGraphSetDelayBlock);\n"]}