{"version":3,"file":"motionBlurPostProcess.js","sourceRoot":"","sources":["../../../../dev/core/src/PostProcesses/motionBlurPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport \"../Rendering/geometryBufferRendererSceneComponent\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinMotionBlurPostProcess } from \"./thinMotionBlurPostProcess\";\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public get motionStrength() {\r\n        return this._effectWrapper.motionStrength;\r\n    }\r\n\r\n    public set motionStrength(value: number) {\r\n        this._effectWrapper.motionStrength = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._effectWrapper.motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._effectWrapper.motionBlurSamples = samples;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._effectWrapper.isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this.isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._effectWrapper.isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinMotionBlurPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinMotionBlurPostProcess.Uniforms,\r\n            samplers: ThinMotionBlurPostProcess.Samplers,\r\n            defines: ThinMotionBlurPostProcess.Defines,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinMotionBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinMotionBlurPostProcess(name, scene, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = this.isObjectBased;\r\n            }\r\n        } else {\r\n            scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public override dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode() {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return;\r\n        }\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            this._geometryBufferRenderer.enableVelocity = this.isObjectBased;\r\n        }\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_VELOCITY_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_DEPTH_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        this._effectWrapper.textureWidth = this.width;\r\n        this._effectWrapper.textureHeight = this.height;\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        this._effectWrapper.textureWidth = this.width;\r\n        this._effectWrapper.textureHeight = this.height;\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new MotionBlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\r\n"]}