{"version":3,"file":"babylonFileParser.function.js","sourceRoot":"","sources":["../../../../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts"],"names":[],"mappings":"AAgBA;;GAEG;AACH,MAAM,kBAAkB,GAAyC,EAAE,CAAC;AAEpE;;GAEG;AACH,MAAM,4BAA4B,GAAmD,EAAE,CAAC;AAExF;;;;GAIG;AACH,MAAM,UAAU,SAAS,CAAC,IAAY,EAAE,MAAyB;IAC7D,kBAAkB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACtC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,SAAS,CAAC,IAAY;IAClC,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3B,OAAO,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAY,EAAE,MAAmC;IACjF,4BAA4B,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAY;IAC5C,IAAI,4BAA4B,CAAC,IAAI,CAAC,EAAE,CAAC;QACrC,OAAO,4BAA4B,CAAC,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,KAAK,CAAC,QAAa,EAAE,KAAY,EAAE,SAAyB,EAAE,OAAe;IACzF,KAAK,MAAM,UAAU,IAAI,kBAAkB,EAAE,CAAC;QAC1C,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,kBAAkB,EAAE,UAAU,CAAC,EAAE,CAAC;YACvE,kBAAkB,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QACxE,CAAC;IACL,CAAC;AACL,CAAC","sourcesContent":["import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (BabylonFileParsers[name]) {\r\n        return BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (IndividualBabylonFileParsers[name]) {\r\n        return IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(BabylonFileParsers, parserName)) {\r\n            BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n"]}