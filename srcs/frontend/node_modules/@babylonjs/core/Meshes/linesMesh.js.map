{"version":3,"file":"linesMesh.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/linesMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { IShaderMaterialOptions } from \"../Materials/shaderMaterial\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { MeshCreationOptions } from \"./mesh\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Force all the LineMeshes to compile their default color material to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _isShaderMaterial(shader: Nullable<Material>): shader is ShaderMaterial {\r\n        if (!shader) {\r\n            return false;\r\n        }\r\n\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    private _ownsMaterial: boolean = false;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options: Partial<IShaderMaterialOptions> = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n            shaderLanguage: ShaderLanguage.GLSL,\r\n        };\r\n\r\n        if (!this.useVertexAlpha) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!this.useVertexColor) {\r\n            options.uniforms!.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXCOLOR\");\r\n            options.attributes!.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            const engine = this.getScene().getEngine();\r\n\r\n            if (engine.isWebGPU && !LinesMesh.ForceGLSL) {\r\n                this._shaderLanguage = ShaderLanguage.WGSL;\r\n            }\r\n\r\n            options.shaderLanguage = this._shaderLanguage;\r\n            options.extraInitializationsAsync = async () => {\r\n                if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                    await Promise.all([import(\"../ShadersWGSL/color.vertex\"), import(\"../ShadersWGSL/color.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../Shaders/color.vertex\"), import(\"../Shaders/color.fragment\")]);\r\n                }\r\n            };\r\n\r\n            const material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            material.doNotSerialize = true;\r\n\r\n            this._ownsMaterial = true;\r\n            this._setInternalMaterial(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material as Material;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override set material(value: Nullable<Material>) {\r\n        const currentMaterial = this.material;\r\n        if (currentMaterial === value) {\r\n            return;\r\n        }\r\n\r\n        const shouldDispose = currentMaterial && this._ownsMaterial;\r\n        this._ownsMaterial = false;\r\n        this._setInternalMaterial(value);\r\n\r\n        if (shouldDispose) {\r\n            currentMaterial?.dispose();\r\n        }\r\n    }\r\n\r\n    private _setInternalMaterial(material: Nullable<Material>) {\r\n        this._setMaterial(material);\r\n        if (this.material) {\r\n            this.material.fillMode = Material.LineListDrawMode;\r\n            (this.material as any).disableLighting = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this.material)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this.material.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh (this disposes of the automatically created material if not instructed otherwise).\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is used to force disposing the material in case it is not the default one\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material might be disposed)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            if (this._ownsMaterial) {\r\n                this.material?.dispose(false, false, true);\r\n            } else if (disposeMaterialAndTextures) {\r\n                this.material?.dispose(false, false, true);\r\n            }\r\n        }\r\n\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> | MeshCreationOptions = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        if (newParent && (newParent as Node)._addToSceneRootNodes === undefined) {\r\n            const createOptions = newParent as MeshCreationOptions;\r\n            createOptions.source = this;\r\n\r\n            return new LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source as Nullable<LinesMesh>, createOptions.doNotCloneChildren);\r\n        }\r\n\r\n        return new LinesMesh(name, this.getScene(), newParent as Nullable<Node>, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public override createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n"]}