
import { FrameGraphTask } from "../../frameGraphTask.js";
import { textureSizeIsObject } from "../../../Materials/Textures/textureCreationOptions.js";
/**
 * Task which applies a post process.
 */
export class FrameGraphPostProcessTask extends FrameGraphTask {
    /**
     * The draw wrapper used by the post process
     */
    get drawWrapper() {
        return this._postProcessDrawWrapper;
    }
    /**
     * Constructs a new post process task.
     * @param name Name of the task.
     * @param frameGraph The frame graph this task is associated with.
     * @param postProcess The post process to apply.
     */
    constructor(name, frameGraph, postProcess) {
        super(name, frameGraph);
        /**
         * The sampling mode to use for the source texture.
         */
        this.sourceSamplingMode = 2;
        /**
         * If true, the depth attachment will be read-only.
         * This means that the post process will not write to the depth buffer.
         * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
         * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
         */
        this.depthReadOnly = false;
        /**
         * If true, the stencil attachment will be read-only.
         * This means that the post process will not write to the stencil buffer.
         * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
         * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
         */
        this.stencilReadOnly = false;
        /**
         * If true, color write will be disabled when applying the post process.
         * This means that the post process will not write to the color buffer.
         */
        this.disableColorWrite = false;
        /**
         * If true, the post process will be generated by a back face full-screen quad (CW order).
         */
        this.drawBackFace = false;
        /**
         * If depth testing should be enabled (default is true).
         */
        this.depthTest = true;
        this.postProcess = postProcess;
        this._postProcessDrawWrapper = this.postProcess.drawWrapper;
        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.outputDepthAttachmentTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.onTexturesAllocatedObservable.add((context) => {
            if (this.sourceTexture !== undefined) {
                context.setTextureSamplingMode(this.sourceTexture, this.sourceSamplingMode);
            }
        });
    }
    isReady() {
        return this.postProcess.isReady();
    }
    record(skipCreationOfDisabledPasses = false, additionalExecute, additionalBindings) {
        if (this.sourceTexture === undefined && this.targetTexture === undefined) {
            throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);
        }
        const sourceTextureCreationOptions = this.sourceTexture !== undefined ? this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture) : undefined;
        if (sourceTextureCreationOptions) {
            sourceTextureCreationOptions.options.samples = 1;
        }
        this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture, this.name, sourceTextureCreationOptions);
        if (this.depthAttachmentTexture !== undefined) {
            this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture, this.depthAttachmentTexture);
        }
        if (sourceTextureCreationOptions) {
            const sourceSize = !sourceTextureCreationOptions.sizeIsPercentage
                ? textureSizeIsObject(sourceTextureCreationOptions.size)
                    ? sourceTextureCreationOptions.size
                    : { width: sourceTextureCreationOptions.size, height: sourceTextureCreationOptions.size }
                : this._frameGraph.textureManager.getAbsoluteDimensions(sourceTextureCreationOptions.size);
            this._sourceWidth = sourceSize.width;
            this._sourceHeight = sourceSize.height;
        }
        const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.outputTexture);
        this._outputWidth = outputTextureDescription.size.width;
        this._outputHeight = outputTextureDescription.size.height;
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.depthReadOnly = this.depthReadOnly;
        pass.stencilReadOnly = this.stencilReadOnly;
        pass.addDependencies(this.sourceTexture);
        pass.setRenderTarget(this.outputTexture);
        pass.setRenderTargetDepth(this.depthAttachmentTexture);
        pass.setExecuteFunc((context) => {
            additionalExecute?.(context);
            context.applyFullScreenEffect(this._postProcessDrawWrapper, () => {
                if (this.sourceTexture !== undefined) {
                    context.bindTextureHandle(this._postProcessDrawWrapper.effect, "textureSampler", this.sourceTexture);
                }
                additionalBindings?.(context);
                this.postProcess.bind();
            }, this.stencilState, this.disableColorWrite, this.drawBackFace, this.depthTest);
        });
        if (!skipCreationOfDisabledPasses) {
            const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
            passDisabled.depthReadOnly = this.depthReadOnly;
            passDisabled.stencilReadOnly = this.stencilReadOnly;
            passDisabled.addDependencies(this.sourceTexture);
            passDisabled.setRenderTarget(this.outputTexture);
            passDisabled.setRenderTargetDepth(this.depthAttachmentTexture);
            passDisabled.setExecuteFunc((context) => {
                if (this.sourceTexture !== undefined) {
                    context.copyTexture(this.sourceTexture);
                }
            });
        }
        return pass;
    }
    dispose() {
        this.postProcess.dispose();
        super.dispose();
    }
}
//# sourceMappingURL=postProcessTask.js.map