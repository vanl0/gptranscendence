import type { FrameGraph, FrameGraphTextureHandle, DrawWrapper, FrameGraphRenderPass, FrameGraphRenderContext, EffectWrapper, IStencilState } from "../../../index.js";
import { FrameGraphTask } from "../../frameGraphTask.js";
/**
 * Task which applies a post process.
 */
export declare class FrameGraphPostProcessTask extends FrameGraphTask {
    /**
     * The source texture to apply the post process on.
     * It's allowed to be undefined if the post process does not require a source texture.
     * In that case, targetTexture must be provided.
     */
    sourceTexture?: FrameGraphTextureHandle;
    /**
     * The sampling mode to use for the source texture.
     */
    sourceSamplingMode: number;
    /**
     * The target texture to render the post process to.
     * If not supplied, a texture with the same configuration as the source texture will be created.
     */
    targetTexture?: FrameGraphTextureHandle;
    /**
     * The stencil state to use for the post process (optional).
     */
    stencilState?: IStencilState;
    /**
     * The depth attachment texture to use for the post process (optional).
     * Note that a post-process task never writes to the depth buffer: attaching a depth texture is only useful if you want to test against the depth/stencil aspect or write to the stencil buffer.
     */
    depthAttachmentTexture?: FrameGraphTextureHandle;
    /**
     * If true, the depth attachment will be read-only.
     * This means that the post process will not write to the depth buffer.
     * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
     * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
     */
    depthReadOnly: boolean;
    /**
     * If true, the stencil attachment will be read-only.
     * This means that the post process will not write to the stencil buffer.
     * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
     * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
     */
    stencilReadOnly: boolean;
    /**
     * If true, color write will be disabled when applying the post process.
     * This means that the post process will not write to the color buffer.
     */
    disableColorWrite: boolean;
    /**
     * If true, the post process will be generated by a back face full-screen quad (CW order).
     */
    drawBackFace: boolean;
    /**
     * If depth testing should be enabled (default is true).
     */
    depthTest: boolean;
    /**
     * The output texture of the post process.
     */
    readonly outputTexture: FrameGraphTextureHandle;
    /**
     * The output depth attachment texture.
     * This texture will point to the same texture than the depthAttachmentTexture property if it is set.
     * Note, however, that the handle itself will be different!
     */
    readonly outputDepthAttachmentTexture: FrameGraphTextureHandle;
    /**
     * The post process to apply.
     */
    readonly postProcess: EffectWrapper;
    /**
     * The draw wrapper used by the post process
     */
    get drawWrapper(): DrawWrapper;
    protected readonly _postProcessDrawWrapper: DrawWrapper;
    protected _sourceWidth: number;
    protected _sourceHeight: number;
    protected _outputWidth: number;
    protected _outputHeight: number;
    /**
     * Constructs a new post process task.
     * @param name Name of the task.
     * @param frameGraph The frame graph this task is associated with.
     * @param postProcess The post process to apply.
     */
    constructor(name: string, frameGraph: FrameGraph, postProcess: EffectWrapper);
    isReady(): boolean;
    record(skipCreationOfDisabledPasses?: boolean, additionalExecute?: (context: FrameGraphRenderContext) => void, additionalBindings?: (context: FrameGraphRenderContext) => void): FrameGraphRenderPass;
    dispose(): void;
}
