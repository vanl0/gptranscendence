{"version":3,"file":"csmShadowGeneratorTask.js","sourceRoot":"","sources":["../../../../../../dev/core/src/FrameGraph/Tasks/Rendering/csmShadowGeneratorTask.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FrameGraphTextureHandle, FrameGraph, Scene } from \"core/index\";\r\nimport { CascadedShadowGenerator } from \"../../../Lights/Shadows/cascadedShadowGenerator\";\r\nimport { FrameGraphShadowGeneratorTask } from \"./shadowGeneratorTask\";\r\nimport { DirectionalLight } from \"../../../Lights/directionalLight\";\r\nimport { DepthTextureType, ThinMinMaxReducer } from \"../../../Misc/thinMinMaxReducer\";\r\nimport { FrameGraphPostProcessTask } from \"../PostProcesses/postProcessTask\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { textureSizeIsObject } from \"../../../Materials/Textures/textureCreationOptions\";\r\n\r\n/**\r\n * Task used to generate a cascaded shadow map from a list of objects.\r\n */\r\nexport class FrameGraphCascadedShadowGeneratorTask extends FrameGraphShadowGeneratorTask {\r\n    protected override _shadowGenerator: CascadedShadowGenerator | undefined;\r\n\r\n    /**\r\n     * Checks if a shadow generator task is a cascaded shadow generator task.\r\n     * @param task The task to check.\r\n     * @returns True if the task is a cascaded shadow generator task, else false.\r\n     */\r\n    public static IsCascadedShadowGenerator(task: FrameGraphShadowGeneratorTask): task is FrameGraphCascadedShadowGeneratorTask {\r\n        return (task as FrameGraphCascadedShadowGeneratorTask).numCascades !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The depth texture used by the autoCalcDepthBounds feature (optional if autoCalcDepthBounds is set to false)\r\n     * This texture is used to compute the min/max depth bounds of the scene to setup the cascaded shadow generator.\r\n     * Warning: Do not set a texture if you are not using the autoCalcDepthBounds feature, to avoid generating a depth texture that will not be used.\r\n     */\r\n    public depthTexture?: FrameGraphTextureHandle;\r\n\r\n    /**\r\n     * The type of the depth texture used by the autoCalcDepthBounds feature.\r\n     */\r\n    public depthTextureType: DepthTextureType = DepthTextureType.NormalizedViewDepth;\r\n\r\n    private _numCascades = CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\r\n    /**\r\n     * The number of cascades.\r\n     */\r\n    public get numCascades() {\r\n        return this._numCascades;\r\n    }\r\n\r\n    public set numCascades(value: number) {\r\n        if (value === this._numCascades) {\r\n            return;\r\n        }\r\n\r\n        this._numCascades = value;\r\n        this._setupShadowGenerator();\r\n    }\r\n\r\n    private _debug = false;\r\n    /**\r\n     * Gets or sets a value indicating whether the shadow generator should display the cascades.\r\n     */\r\n    public get debug() {\r\n        return this._debug;\r\n    }\r\n\r\n    public set debug(value: boolean) {\r\n        if (value === this._debug) {\r\n            return;\r\n        }\r\n\r\n        this._debug = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.debug = value;\r\n        }\r\n    }\r\n\r\n    private _stabilizeCascades = false;\r\n    /**\r\n     * Gets or sets a value indicating whether the shadow generator should stabilize the cascades.\r\n     */\r\n    public get stabilizeCascades() {\r\n        return this._stabilizeCascades;\r\n    }\r\n\r\n    public set stabilizeCascades(value: boolean) {\r\n        if (value === this._stabilizeCascades) {\r\n            return;\r\n        }\r\n\r\n        this._stabilizeCascades = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.stabilizeCascades = value;\r\n        }\r\n    }\r\n\r\n    private _lambda = 0.5;\r\n    /**\r\n     * Gets or sets the lambda parameter of the shadow generator.\r\n     */\r\n    public get lambda() {\r\n        return this._lambda;\r\n    }\r\n\r\n    public set lambda(value: number) {\r\n        if (value === this._lambda) {\r\n            return;\r\n        }\r\n\r\n        this._lambda = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.lambda = value;\r\n        }\r\n    }\r\n\r\n    private _cascadeBlendPercentage = 0.1;\r\n    /**\r\n     * Gets or sets the cascade blend percentage.\r\n     */\r\n    public get cascadeBlendPercentage() {\r\n        return this._cascadeBlendPercentage;\r\n    }\r\n\r\n    public set cascadeBlendPercentage(value: number) {\r\n        if (value === this._cascadeBlendPercentage) {\r\n            return;\r\n        }\r\n\r\n        this._cascadeBlendPercentage = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.cascadeBlendPercentage = value;\r\n        }\r\n    }\r\n\r\n    private _depthClamp = true;\r\n    /**\r\n     * Gets or sets a value indicating whether the shadow generator should use depth clamping.\r\n     */\r\n    public get depthClamp() {\r\n        return this._depthClamp;\r\n    }\r\n\r\n    public set depthClamp(value: boolean) {\r\n        if (value === this._depthClamp) {\r\n            return;\r\n        }\r\n\r\n        this._depthClamp = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.depthClamp = value;\r\n        }\r\n    }\r\n\r\n    private _autoCalcDepthBounds = false;\r\n    /**\r\n     * Gets or sets a value indicating whether the shadow generator should automatically calculate the depth bounds.\r\n     */\r\n    public get autoCalcDepthBounds() {\r\n        return this._autoCalcDepthBounds;\r\n    }\r\n\r\n    public set autoCalcDepthBounds(value: boolean) {\r\n        if (value === this._autoCalcDepthBounds) {\r\n            return;\r\n        }\r\n\r\n        this._autoCalcDepthBounds = value;\r\n        this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;\r\n\r\n        if (!value) {\r\n            this._shadowGenerator?.setMinMaxDistance(0, 1);\r\n        }\r\n\r\n        // All passes but the last one are related to min/max reduction and should be enabled/disabled depending on autoCalcDepthBounds value\r\n        const passes = this.passes;\r\n        for (let i = 0; i < passes.length - 1; ++i) {\r\n            passes[i].disabled = !value;\r\n        }\r\n    }\r\n\r\n    private _currentAutoCalcDepthBoundsCounter = 0;\r\n    private _autoCalcDepthBoundsRefreshRate = 1;\r\n    /**\r\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\r\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\r\n     */\r\n    public get autoCalcDepthBoundsRefreshRate() {\r\n        return this._autoCalcDepthBoundsRefreshRate;\r\n    }\r\n\r\n    public set autoCalcDepthBoundsRefreshRate(value: number) {\r\n        this._autoCalcDepthBoundsRefreshRate = value;\r\n        this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;\r\n    }\r\n\r\n    private _shadowMaxZ = 10000;\r\n    /**\r\n     * Gets or sets the maximum shadow Z value.\r\n     */\r\n    public get shadowMaxZ() {\r\n        return this._shadowMaxZ;\r\n    }\r\n\r\n    public set shadowMaxZ(value: number) {\r\n        if (value === this._shadowMaxZ) {\r\n            return;\r\n        }\r\n\r\n        this._shadowMaxZ = value;\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.shadowMaxZ = value;\r\n        }\r\n    }\r\n\r\n    protected readonly _thinMinMaxReducer: ThinMinMaxReducer;\r\n\r\n    /**\r\n     * Creates a new shadow generator task.\r\n     * @param name The name of the task.\r\n     * @param frameGraph The frame graph the task belongs to.\r\n     * @param scene The scene to create the shadow generator for.\r\n     */\r\n    constructor(name: string, frameGraph: FrameGraph, scene: Scene) {\r\n        super(name, frameGraph, scene);\r\n\r\n        this._thinMinMaxReducer = new ThinMinMaxReducer(scene);\r\n\r\n        this._thinMinMaxReducer.onAfterReductionPerformed.add((minmax: { min: number; max: number }) => {\r\n            if (!this._shadowGenerator) {\r\n                return;\r\n            }\r\n\r\n            const camera = this.camera;\r\n\r\n            let min = minmax.min,\r\n                max = minmax.max;\r\n\r\n            if (min >= max) {\r\n                min = 0;\r\n                max = 1;\r\n            } else if (camera && this.depthTextureType !== DepthTextureType.NormalizedViewDepth) {\r\n                if (this.depthTextureType === DepthTextureType.ScreenDepth) {\r\n                    const engine = this._frameGraph.engine;\r\n                    const projectionMatrix = camera.getProjectionMatrix();\r\n                    const p2z = projectionMatrix.m[10];\r\n                    const p3z = projectionMatrix.m[14];\r\n\r\n                    if (!engine.isNDCHalfZRange) {\r\n                        // Convert to NDC depth\r\n                        min = min * 2 - 1;\r\n                        max = max * 2 - 1;\r\n                    }\r\n\r\n                    // Convert to view depth\r\n                    min = p3z / (min - p2z);\r\n                    max = p3z / (max - p2z);\r\n                }\r\n\r\n                // Convert to normalized view depth\r\n                const zNear = camera.minZ;\r\n                const zFar = camera.maxZ;\r\n\r\n                min = (min - zNear) / (zFar - zNear);\r\n                max = (max - zNear) / (zFar - zNear);\r\n            }\r\n\r\n            if (min !== this._shadowGenerator.minDistance || max !== this._shadowGenerator.maxDistance) {\r\n                this._shadowGenerator.setMinMaxDistance(min, max);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected override _createShadowGenerator() {\r\n        if (!(this.light instanceof DirectionalLight)) {\r\n            throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: the CSM shadow generator only supports directional lights.`);\r\n        }\r\n        this._shadowGenerator = new CascadedShadowGenerator(this.mapSize, this.light, this.useFloat32TextureType, this.camera, this.useRedTextureFormat);\r\n        this._shadowGenerator.numCascades = this._numCascades;\r\n    }\r\n\r\n    protected override _setupShadowGenerator() {\r\n        super._setupShadowGenerator();\r\n\r\n        const shadowGenerator = this._shadowGenerator;\r\n        if (shadowGenerator === undefined) {\r\n            return;\r\n        }\r\n\r\n        shadowGenerator.debug = this._debug;\r\n        shadowGenerator.stabilizeCascades = this._stabilizeCascades;\r\n        shadowGenerator.lambda = this._lambda;\r\n        shadowGenerator.cascadeBlendPercentage = this._cascadeBlendPercentage;\r\n        shadowGenerator.depthClamp = this._depthClamp;\r\n        shadowGenerator.shadowMaxZ = this._shadowMaxZ;\r\n    }\r\n\r\n    public override record() {\r\n        if (this.light === undefined || this.objectList === undefined || this.camera === undefined) {\r\n            throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: light, objectList and camera are required`);\r\n        }\r\n\r\n        if (this.depthTexture !== undefined) {\r\n            const depthTextureCreationOptions = this._frameGraph.textureManager.getTextureCreationOptions(this.depthTexture);\r\n\r\n            const size = !depthTextureCreationOptions.sizeIsPercentage\r\n                ? textureSizeIsObject(depthTextureCreationOptions.size)\r\n                    ? depthTextureCreationOptions.size\r\n                    : { width: depthTextureCreationOptions.size, height: depthTextureCreationOptions.size }\r\n                : this._frameGraph.textureManager.getAbsoluteDimensions(depthTextureCreationOptions.size);\r\n\r\n            const width = size.width;\r\n            const height = size.height;\r\n\r\n            depthTextureCreationOptions.sizeIsPercentage = false;\r\n            depthTextureCreationOptions.options.formats = [Constants.TEXTUREFORMAT_RG];\r\n            depthTextureCreationOptions.options.samples = 1;\r\n\r\n            this._thinMinMaxReducer.setTextureDimensions(width, height, this.depthTextureType);\r\n\r\n            const reductionSteps = this._thinMinMaxReducer.reductionSteps;\r\n\r\n            let targetTexture: FrameGraphTextureHandle;\r\n\r\n            this._frameGraph.addPass(`${this.name} Before Min Max Reduction`).setExecuteFunc((context) => {\r\n                context.pushDebugGroup(`Min Max Reduction`);\r\n            });\r\n\r\n            for (let i = 0; i < reductionSteps.length - 1; ++i) {\r\n                const reductionStep = reductionSteps[i];\r\n\r\n                depthTextureCreationOptions.size = { width: reductionSteps[i + 1].textureWidth, height: reductionSteps[i + 1].textureHeight };\r\n\r\n                const postProcess = new FrameGraphPostProcessTask(reductionStep.name, this._frameGraph, reductionStep);\r\n\r\n                postProcess.sourceTexture = i == 0 ? this.depthTexture : targetTexture!;\r\n                postProcess.sourceSamplingMode = Constants.TEXTURE_NEAREST_NEAREST;\r\n                postProcess.targetTexture = this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} ${reductionStep.name}`, depthTextureCreationOptions);\r\n\r\n                postProcess.record(true);\r\n\r\n                targetTexture = postProcess.outputTexture;\r\n            }\r\n\r\n            this._frameGraph.addPass(`${this.name} After Min Max Reduction`).setExecuteFunc((context) => {\r\n                context.popDebugGroup();\r\n                if (this._autoCalcDepthBounds && this._currentAutoCalcDepthBoundsCounter >= 0) {\r\n                    if (++this._currentAutoCalcDepthBoundsCounter >= this._autoCalcDepthBoundsRefreshRate) {\r\n                        const minMaxTexture = context.getTextureFromHandle(targetTexture!);\r\n                        if (minMaxTexture) {\r\n                            this._thinMinMaxReducer.readMinMax(minMaxTexture);\r\n                        }\r\n                    }\r\n                    this._currentAutoCalcDepthBoundsCounter %= this._autoCalcDepthBoundsRefreshRate;\r\n                    if (this._autoCalcDepthBoundsRefreshRate === 0) {\r\n                        this._currentAutoCalcDepthBoundsCounter = -1;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        super.record();\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n        this._thinMinMaxReducer.dispose();\r\n    }\r\n}\r\n"]}