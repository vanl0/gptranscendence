{"version":3,"file":"flowMap.js","sourceRoot":"","sources":["../../../../dev/core/src/Particles/flowMap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Particle } from \"../Particles/particle\";\r\nimport type { IVector3Like } from \"../Maths/math.like\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\n\r\nconst FlowVector = new Vector3(0, 0, 0);\r\nconst ScaledFlowVector = new Vector3(0, 0, 0);\r\nconst ScreenPos = new Vector3(0, 0, 0);\r\n\r\n/**\r\n * Represents an object that can move or be influenced by FlowMap\r\n */\r\nexport interface IFlowable {\r\n    /**\r\n     * The direction vector indicating the flow or movement direction of the object.\r\n     */\r\n    direction: Vector3;\r\n\r\n    /**\r\n     * The current position of the object in 3D space.\r\n     */\r\n    position: Vector3;\r\n}\r\n\r\n/**\r\n * Class used to represent a particle flow map.\r\n * #5DM02T#7\r\n * GPUParts: #5DM02T#12 (webgl2)\r\n * GPUParts: #5DM02T#13 (webgpu)\r\n */\r\nexport class FlowMap {\r\n    /**\r\n     * Create a new flow map.\r\n     * @param width defines the width of the flow map\r\n     * @param height defines the height of the flow map\r\n     * @param data defines the data of the flow map\r\n     */\r\n    constructor(\r\n        public readonly width: number,\r\n        public readonly height: number,\r\n        public readonly data: Uint8ClampedArray\r\n    ) {}\r\n\r\n    public processFlowable(flowable: IFlowable, strength = 1, flowMapSamplePosOrTransformationMatrix?: IVector3Like | Matrix) {\r\n        if (!flowMapSamplePosOrTransformationMatrix) {\r\n            return;\r\n        }\r\n\r\n        // Convert world pos to screen pos\r\n        if (flowMapSamplePosOrTransformationMatrix instanceof Matrix) {\r\n            Vector3.TransformCoordinatesToRef(flowable.position, flowMapSamplePosOrTransformationMatrix, ScreenPos);\r\n        } else {\r\n            ScreenPos.x = flowMapSamplePosOrTransformationMatrix.x;\r\n            ScreenPos.y = flowMapSamplePosOrTransformationMatrix.y;\r\n            ScreenPos.z = flowMapSamplePosOrTransformationMatrix.z;\r\n        }\r\n\r\n        const u = ScreenPos.x * 0.5 + 0.5;\r\n        const v = 1.0 - (ScreenPos.y * 0.5 + 0.5);\r\n\r\n        const x = Math.floor(u * this.width);\r\n        const y = Math.floor(v * this.height);\r\n\r\n        // Clamp\r\n        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\r\n            return;\r\n        }\r\n\r\n        const index = (y * this.width + x) * 4;\r\n        const r = this.data[index];\r\n        const g = this.data[index + 1];\r\n        const b = this.data[index + 2];\r\n        const a = this.data[index + 3];\r\n\r\n        const fx = (r / 255.0) * 2.0 - 1.0;\r\n        const fy = (g / 255.0) * 2.0 - 1.0;\r\n        const fz = (b / 255.0) * 2.0 - 1.0;\r\n        const localStrength = a / 255.0;\r\n\r\n        FlowVector.set(fx, fy, fz);\r\n        FlowVector.scaleToRef(strength * localStrength, ScaledFlowVector);\r\n\r\n        flowable.direction.addInPlace(ScaledFlowVector); // Update IFlowable velocity\r\n    }\r\n\r\n    /** @internal */\r\n    public _processParticle(particle: Particle, strength = 1, matrix?: Matrix) {\r\n        this.processFlowable(particle, strength, matrix);\r\n    }\r\n\r\n    /**\r\n     * Creates a FlowMap from a url.\r\n     * @param url The url of the image to load\r\n     * @returns a promise that resolves to a FlowMap object\r\n     */\r\n    public static async FromUrlAsync(url: string): Promise<FlowMap> {\r\n        return await new Promise((resolve, reject) => {\r\n            const flowCanvas = document.createElement(\"canvas\");\r\n            const flowCtx = flowCanvas.getContext(\"2d\")!;\r\n            let flowImageData = null;\r\n\r\n            const flowMapImage = new Image();\r\n            flowMapImage.crossOrigin = \"anonymous\"; // If loading from another domain\r\n            flowMapImage.src = url;\r\n\r\n            flowMapImage.onerror = (e) => {\r\n                reject(new Error(`Failed to load image: ${url} : ${e}`));\r\n            };\r\n\r\n            flowMapImage.onload = () => {\r\n                flowCanvas.width = flowMapImage.width;\r\n                flowCanvas.height = flowMapImage.height;\r\n                flowCtx.drawImage(flowMapImage, 0, 0);\r\n                flowImageData = flowCtx.getImageData(0, 0, flowCanvas.width, flowCanvas.height);\r\n\r\n                resolve(new FlowMap(flowCanvas.width, flowCanvas.height, flowImageData.data));\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load from a texture\r\n     * @param texture defines the source texture\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public static async ExtractFromTextureAsync(texture: Texture) {\r\n        const data = await TextureTools.GetTextureDataAsync(texture);\r\n        const { width, height } = texture.getSize();\r\n        return new FlowMap(width, height, new Uint8ClampedArray(data));\r\n    }\r\n}\r\n"]}