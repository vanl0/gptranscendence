{"version":3,"file":"drawWrapper.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/drawWrapper.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,WAAW,EAAE,+BAA8B;AAEpD;;;GAGG;AACH,MAAM,OAAO,WAAW;IAoCpB;;;;OAIG;IACI,MAAM,CAAC,SAAS,CAAC,MAA4B;QAChD,OAAQ,MAAiB,CAAC,kBAAkB,KAAK,SAAS,CAAC,CAAC,CAAE,MAAsB,CAAC,MAAM,CAAC,CAAC,CAAE,MAAiB,CAAC;IACrH,CAAC;IAED;;;;;OAKG;IACH,YAAY,MAAsB,EAAE,qBAAqB,GAAG,IAAI;QAjChE;;;WAGG;QACI,wBAAmB,GAAG,KAAK,CAAC;QAEnC;;;WAGG;QACI,2BAAsB,GAAG,IAAI,CAAC;QAErC;;;WAGG;QACI,iCAA4B,GAAsB,IAAI,CAAC;QAkB1D,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,iBAAiB,EAAE,CAAC;QAC9C,IAAI,qBAAqB,EAAE,CAAC;YACxB,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,qBAAqB,EAAE,CAAC;QAC1D,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACI,SAAS,CAAC,MAAwB,EAAE,OAA4C,EAAE,YAAY,GAAG,IAAI;QACxG,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;YACxB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAC3B,CAAC;QACD,IAAI,YAAY,EAAE,CAAC;YACf,IAAI,CAAC,WAAW,EAAE,KAAK,EAAE,CAAC;QAC9B,CAAC;IACL,CAAC;IAED;;;;OAIG;IACI,OAAO,CAAC,SAAS,GAAG,KAAK;QAC5B,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,IAAI,SAAS,EAAE,CAAC;gBACZ,MAAM,CAAC,OAAO,EAAE,CAAC;YACrB,CAAC;iBAAM,CAAC;gBACJ,WAAW,CAAC,YAAY,CAAC,GAAG,EAAE;oBAC1B,MAAM,CAAC,SAAS,EAAE,CAAC,oBAAoB,CAAC,OAAO,CAAC,GAAG,EAAE;wBACjD,MAAM,CAAC,OAAO,EAAE,CAAC;oBACrB,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,CAAC;YACP,CAAC;YACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACvB,CAAC;QACD,IAAI,CAAC,WAAW,EAAE,OAAO,EAAE,CAAC;IAChC,CAAC;CACJ","sourcesContent":["import type { IDrawContext } from \"../Engines/IDrawContext\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { TimingTools } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Wrapper for an effect and its associated material context and draw context.\r\n * This class is meant to encapsulate the effect and its related contexts, allowing for easier management of rendering states.\r\n */\r\nexport class DrawWrapper {\r\n    /**\r\n     * The effect associated with this wrapper.\r\n     */\r\n    public effect: Nullable<Effect>;\r\n    /**\r\n     * The defines associated with this wrapper.\r\n     */\r\n    public defines: Nullable<string | MaterialDefines>;\r\n    /**\r\n     * The material context associated with this wrapper.\r\n     */\r\n    public materialContext?: IMaterialContext;\r\n    /**\r\n     * The draw context associated with this wrapper.\r\n     */\r\n    public drawContext?: IDrawContext;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Forces the code from bindForSubMesh to be fully run the next time it is called\r\n     */\r\n    public _forceRebindOnNextCall = true;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously using instances\r\n     */\r\n    public _wasPreviouslyUsingInstances: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * Retrieves the effect from a DrawWrapper or Effect instance.\r\n     * @param effect The effect or DrawWrapper instance to retrieve the effect from.\r\n     * @returns The effect associated with the given instance, or null if not found.\r\n     */\r\n    public static GetEffect(effect: Effect | DrawWrapper): Nullable<Effect> {\r\n        return (effect as Effect).getPipelineContext === undefined ? (effect as DrawWrapper).effect : (effect as Effect);\r\n    }\r\n\r\n    /**\r\n     * Creates a new DrawWrapper instance.\r\n     * Note that drawContext is always created (but may end up being undefined if the engine doesn't need draw contexts), but materialContext is optional.\r\n     * @param engine The engine to create the draw wrapper for.\r\n     * @param createMaterialContext If true, creates a material context for this wrapper (default is true).\r\n     */\r\n    constructor(engine: AbstractEngine, createMaterialContext = true) {\r\n        this.effect = null;\r\n        this.defines = null;\r\n        this.drawContext = engine.createDrawContext();\r\n        if (createMaterialContext) {\r\n            this.materialContext = engine.createMaterialContext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the effect and its associated defines for this wrapper.\r\n     * @param effect The effect to associate with this wrapper.\r\n     * @param defines The defines to associate with this wrapper.\r\n     * @param resetContext If true, resets the draw context (default is true).\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines?: Nullable<string | MaterialDefines>, resetContext = true): void {\r\n        this.effect = effect;\r\n        if (defines !== undefined) {\r\n            this.defines = defines;\r\n        }\r\n        if (resetContext) {\r\n            this.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the effect wrapper and its resources\r\n     * @param immediate if the effect should be disposed immediately or on the next frame.\r\n     * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this.effect) {\r\n            const effect = this.effect;\r\n            if (immediate) {\r\n                effect.dispose();\r\n            } else {\r\n                TimingTools.SetImmediate(() => {\r\n                    effect.getEngine().onEndFrameObservable.addOnce(() => {\r\n                        effect.dispose();\r\n                    });\r\n                });\r\n            }\r\n            this.effect = null;\r\n        }\r\n        this.drawContext?.dispose();\r\n    }\r\n}\r\n"]}