{"version":3,"file":"exrTextureLoader.js","sourceRoot":"","sources":["../../../../../../dev/core/src/Materials/Textures/Loaders/exrTextureLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { InternalTexture } from \"../internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { GetExrHeader } from \"./EXR/exrLoader.header\";\r\nimport { CreateDecoderAsync, ScanData } from \"./EXR/exrLoader.decoder\";\r\nimport { ExrLoaderGlobalConfiguration, EXROutputType } from \"./EXR/exrLoader.configuration\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Loader for .exr file format\r\n * @see [PIZ compression](https://playground.babylonjs.com/#4RN0VF#151)\r\n * @see [ZIP compression](https://playground.babylonjs.com/#4RN0VF#146)\r\n * @see [RLE compression](https://playground.babylonjs.com/#4RN0VF#149)\r\n * @see [PXR24 compression](https://playground.babylonjs.com/#4RN0VF#150)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ExrTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param _data contains the texture data\r\n     * @param _texture defines the BabylonJS internal texture\r\n     * @param _createPolynomials will be true if polynomials have been requested\r\n     * @param _onLoad defines the callback to trigger once the texture is ready\r\n     * @param _onError defines the callback to trigger in case of error\r\n     * Cube texture are not supported by .exr files\r\n     */\r\n    public loadCubeData(\r\n        _data: ArrayBufferView | ArrayBufferView[],\r\n        _texture: InternalTexture,\r\n        _createPolynomials: boolean,\r\n        _onLoad: Nullable<(data?: any) => void>,\r\n        _onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".exr not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ) {\r\n        const dataView = new DataView(data.buffer);\r\n\r\n        const offset = { value: 0 };\r\n        const header = GetExrHeader(dataView, offset);\r\n        CreateDecoderAsync(header, dataView, offset, ExrLoaderGlobalConfiguration.DefaultOutputType)\r\n            // eslint-disable-next-line github/no-then\r\n            .then((decoder) => {\r\n                ScanData(decoder, header, dataView, offset);\r\n\r\n                // Updating texture\r\n                const width = header.dataWindow.xMax - header.dataWindow.xMin + 1;\r\n                const height = header.dataWindow.yMax - header.dataWindow.yMin + 1;\r\n                callback(width, height, texture.generateMipMaps, false, () => {\r\n                    const engine = texture.getEngine();\r\n                    texture.format = header.format;\r\n                    texture.type = decoder.textureType;\r\n                    texture.invertY = false;\r\n                    texture._gammaSpace = !header.linearSpace;\r\n                    if (decoder.byteArray) {\r\n                        engine._uploadDataToTextureDirectly(texture, decoder.byteArray, 0, 0, undefined, true);\r\n                    }\r\n                });\r\n            })\r\n            // eslint-disable-next-line github/no-then\r\n            .catch((error) => {\r\n                Logger.Error(\"Failed to load EXR texture: \", error);\r\n            });\r\n    }\r\n}\r\n\r\n/**\r\n * Read the EXR data from an ArrayBufferView asynchronously.\r\n * @param data ArrayBufferView containing the EXR data\r\n * @returns An object containing the width, height, and data of the EXR texture.\r\n */\r\nexport async function ReadExrDataAsync(data: ArrayBuffer): Promise<{ width: number; height: number; data: Nullable<Float32Array> }> {\r\n    const dataView = new DataView(data);\r\n\r\n    const offset = { value: 0 };\r\n    const header = GetExrHeader(dataView, offset);\r\n    try {\r\n        const decoder = await CreateDecoderAsync(header, dataView, offset, EXROutputType.Float);\r\n        ScanData(decoder, header, dataView, offset);\r\n\r\n        if (!decoder.byteArray) {\r\n            Logger.Error(\"Failed to decode EXR data: No byte array available.\");\r\n            return { width: 0, height: 0, data: null };\r\n        }\r\n\r\n        return {\r\n            width: header.dataWindow.xMax - header.dataWindow.xMin + 1,\r\n            height: header.dataWindow.yMax - header.dataWindow.yMin + 1,\r\n            data: new Float32Array(decoder.byteArray),\r\n        };\r\n    } catch (error) {\r\n        Logger.Error(\"Failed to load EXR data: \", error);\r\n    }\r\n\r\n    return { width: 0, height: 0, data: null };\r\n}\r\n"]}