{"version":3,"file":"nodeMaterialDefault.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Node/nodeMaterialDefault.ts"],"names":[],"mappings":"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","sourcesContent":["import { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GaussianSplattingBlock } from \"./Blocks/GaussianSplatting/gaussianSplattingBlock\";\r\nimport { GaussianBlock } from \"./Blocks/GaussianSplatting/gaussianBlock\";\r\nimport { SplatReaderBlock } from \"./Blocks/GaussianSplatting/splatReaderBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { NodeMaterial } from \"./nodeMaterial\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { SmartFilterTextureBlock } from \"./Blocks/Dual/smartFilterTextureBlock\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { AddBlock } from \"./Blocks/addBlock\";\r\nimport { SmartFilterFragmentOutputBlock } from \"./Blocks/Fragment/smartFilterFragmentOutputBlock\";\r\n\r\n/**\r\n * Clear the material and set it to a default state for gaussian splatting\r\n * @param nodeMaterial node material to use\r\n */\r\nexport function SetToDefaultGaussianSplatting(nodeMaterial: NodeMaterial): void {\r\n    nodeMaterial.clear();\r\n\r\n    nodeMaterial.editorData = null;\r\n\r\n    // reading splat datas\r\n    const splatIndex = new InputBlock(\"SplatIndex\");\r\n    splatIndex.setAsAttribute(\"splatIndex\");\r\n\r\n    const splatReader = new SplatReaderBlock(\"SplatReader\");\r\n    splatIndex.connectTo(splatReader);\r\n\r\n    // transforming datas into renderable positions\r\n    const gs = new GaussianSplattingBlock(\"GaussianSplatting\");\r\n    splatReader.connectTo(gs);\r\n\r\n    // world transformation\r\n    const worldInput = new InputBlock(\"World\");\r\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n    const worldPos = new TransformBlock(\"WorldPos\");\r\n\r\n    splatReader.connectTo(worldPos);\r\n    worldInput.connectTo(worldPos);\r\n    worldPos.connectTo(gs, { output: \"xyz\", input: \"splatPosition\" });\r\n\r\n    // view and projections\r\n\r\n    const view = new InputBlock(\"view\");\r\n    view.setAsSystemValue(NodeMaterialSystemValues.View);\r\n\r\n    const projection = new InputBlock(\"Projection\");\r\n    projection.setAsSystemValue(NodeMaterialSystemValues.Projection);\r\n\r\n    worldInput.connectTo(gs, { input: \"world\" });\r\n    view.connectTo(gs, { input: \"view\" });\r\n    projection.connectTo(gs, { input: \"projection\" });\r\n\r\n    const addBlock = new AddBlock(\"Add SH\");\r\n\r\n    // from color to gaussian color\r\n    const gaussian = new GaussianBlock(\"Gaussian\");\r\n    splatReader.connectTo(gaussian, { input: \"splatColor\", output: \"splatColor\" });\r\n\r\n    // fragment and vertex outputs\r\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n    gs.SH.connectTo(addBlock.left);\r\n    gaussian.rgb.connectTo(addBlock.right);\r\n    addBlock.output.connectTo(fragmentOutput.rgb);\r\n    gaussian.alpha.connectTo(fragmentOutput.a);\r\n\r\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n    gs.connectTo(vertexOutput);\r\n\r\n    // Add to nodes\r\n    nodeMaterial.addOutputNode(vertexOutput);\r\n    nodeMaterial.addOutputNode(fragmentOutput);\r\n\r\n    nodeMaterial._mode = NodeMaterialModes.GaussianSplatting;\r\n}\r\n\r\n/**\r\n * Clear the material and set it to a default state for Smart Filter effects\r\n * @param nodeMaterial node material to use\r\n */\r\nexport function SetToDefaultSFE(nodeMaterial: NodeMaterial): void {\r\n    nodeMaterial.clear();\r\n\r\n    nodeMaterial.editorData = null;\r\n\r\n    const uv = new InputBlock(\"uv\");\r\n    uv.setAsAttribute(\"postprocess_uv\");\r\n    uv.comments = \"Normalized screen position to sample our texture with.\";\r\n\r\n    const currentScreen = new SmartFilterTextureBlock(\"Input Texture\");\r\n    currentScreen.comments = \"A placeholder that represents the input texture to compose.\";\r\n    uv.connectTo(currentScreen);\r\n    const textureUrl = Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png\");\r\n    currentScreen.texture = new Texture(textureUrl, nodeMaterial.getScene());\r\n\r\n    const color = new InputBlock(\"Color4\");\r\n    color.value = new Color4(1, 0, 0, 1);\r\n\r\n    const multiply = new MultiplyBlock(\"Multiply\");\r\n    color.connectTo(multiply);\r\n    currentScreen.connectTo(multiply);\r\n\r\n    const fragmentOutput = new SmartFilterFragmentOutputBlock(\"FragmentOutput\");\r\n    multiply.connectTo(fragmentOutput);\r\n\r\n    nodeMaterial.addOutputNode(fragmentOutput);\r\n\r\n    nodeMaterial._mode = NodeMaterialModes.SFE;\r\n}\r\n"]}