{"version":3,"file":"ambientOcclusionBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Fragment/ambientOcclusionBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialConnectionPointDirection, type NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { RandomRange } from \"../../../../Maths/math.scalar.functions\";\r\nimport { RawTexture } from \"../../../Textures/rawTexture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { AbstractEngine } from \"../../../../Engines/abstractEngine\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { ImageSourceBlock } from \"../Dual/imageSourceBlock\";\r\nimport type { DepthSourceBlock } from \"../Dual/depthSourceBlock\";\r\n\r\n/**\r\n * Block used to evaluate screen spaceambient occlusion in a shader\r\n */\r\nexport class AmbientOcclusionBlock extends NodeMaterialBlock {\r\n    private _randomTexture: Texture;\r\n    private _randomSamplerName: string;\r\n\r\n    /**\r\n     * Defines the radius around the analyzed pixel used by the SSAO post-process\r\n     */\r\n    @editableInPropertyPage(\"radius\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0.0001,\r\n    })\r\n    public radius = 0.0001;\r\n\r\n    /**\r\n     * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel\r\n     * Must not be equal to fallOff and superior to fallOff.\r\n     */\r\n    @editableInPropertyPage(\"area\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0,\r\n    })\r\n    public area = 0.0075;\r\n\r\n    /**\r\n     * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel\r\n     * Must not be equal to area and inferior to area.\r\n     */\r\n    @editableInPropertyPage(\"fallOff\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0,\r\n    })\r\n    public fallOff = 0.000001;\r\n\r\n    /**\r\n     * Create a new AmbientOcclusionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\"screenSize\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"occlusion\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"AmbientOcclusionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the source component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the screenSize component\r\n     */\r\n    public get screenSize(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the occlusion output\r\n     */\r\n    public get occlusion(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        if (!this._randomTexture) {\r\n            this._createRandomTexture(effect.getEngine());\r\n        }\r\n\r\n        effect.setTexture(this._randomSamplerName, this._randomTexture);\r\n    }\r\n\r\n    private _createRandomTexture(engine: AbstractEngine): void {\r\n        const size = 512;\r\n\r\n        const data = new Uint8Array(size * size * 4);\r\n        for (let index = 0; index < data.length; ) {\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = 255;\r\n        }\r\n\r\n        const texture = RawTexture.CreateRGBATexture(data, size, size, engine, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE);\r\n        texture.name = \"SSAORandomTexture\";\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        this._randomTexture = texture;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.source.connectedPoint) {\r\n            return this;\r\n        }\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n        const depthSource = this.source.connectedPoint!.ownerBlock as DepthSourceBlock;\r\n\r\n        const occlusion = this._outputs[0];\r\n        const screenSize = this.screenSize;\r\n\r\n        let functionString: string;\r\n\r\n        // Get view position from depth\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = `fn normalFromDepth(depth: f32, coords: vec2f, radius: f32) -> vec3f {\r\n                let offset1: vec2f = vec2f(0.0, radius);\r\n                let offset2: vec2f = vec2f(radius, 0.0);\r\n\r\n                let depth1: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset1, 0.0).r;\r\n                let depth2: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset2, 0.0).r;\r\n\r\n                let p1: vec3f = vec3f(offset1, depth1 - depth);\r\n                let p2: vec3f = vec3f(offset2, depth2 - depth);\r\n\r\n                var normal: vec3f = cross(p1, p2);\r\n                normal.z = -normal.z;\r\n\r\n                return normalize(normal);\r\n            }\r\n            `;\r\n        } else {\r\n            functionString = `vec3 normalFromDepth(float depth, vec2 coords, float radius) {\r\n                vec2 offset1 = vec2(0.0, radius);\r\n                vec2 offset2 = vec2(radius, 0.0);\r\n\r\n                float depth1 = textureLod(${depthSource.samplerName}, coords + offset1, 0.0).r;\r\n                float depth2 = textureLod(${depthSource.samplerName}, coords + offset2, 0.0).r;\r\n\r\n                vec3 p1 = vec3(offset1, depth1 - depth);\r\n                vec3 p2 = vec3(offset2, depth2 - depth);\r\n\r\n                vec3 normal = cross(p1, p2);\r\n                normal.z = -normal.z;\r\n\r\n                return normalize(normal);\r\n            }\r\n            `;\r\n        }\r\n\r\n        state._emitFunction(\"normalFromDepth\", functionString, \"// normalFromDepth function\");\r\n\r\n        // Calculate ambient occlusion\r\n        this._randomSamplerName = state._getFreeVariableName(\"randomSampler\");\r\n\r\n        state._emit2DSampler(this._randomSamplerName);\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = `\r\n            const sampleSphere: array<vec3f, 16> = array<vec3f, 16>(\r\n                vec3f( 0.5381,  0.1856, -0.4319),\r\n                vec3f( 0.1379,  0.2486,  0.4430),\r\n                vec3f( 0.3371,  0.5679, -0.0057),\r\n                vec3f(-0.6999, -0.0451, -0.0019),\r\n                vec3f( 0.0689, -0.1598, -0.8547),\r\n                vec3f( 0.0560,  0.0069, -0.1843),\r\n                vec3f(-0.0146,  0.1402,  0.0762),\r\n                vec3f( 0.0100, -0.1924, -0.0344),\r\n                vec3f(-0.3577, -0.5301, -0.4358),\r\n                vec3f(-0.3169,  0.1063,  0.0158),\r\n                vec3f( 0.0103, -0.5869,  0.0046),\r\n                vec3f(-0.0897, -0.4940,  0.3287),\r\n                vec3f( 0.7119, -0.0154, -0.0918),\r\n                vec3f(-0.0533,  0.0596, -0.5411),\r\n                vec3f( 0.0352, -0.0631,  0.5460),\r\n                vec3f(-0.4776,  0.2847, -0.0271)\r\n            );\r\n\r\n            fn computeOcclusion(screenSize: vec2f) -> f32 {\r\n                let uv: vec2f = fragmentInputs.position.xy / screenSize;\r\n                let random: vec3f = normalize(textureSampleLevel(${this._randomSamplerName}, ${this._randomSamplerName}Sampler, uv * 4.0, 0.0).rgb);\r\n                let depth: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, uv, 0.0).r;\r\n                let position: vec3f = vec3f(uv, depth);\r\n                let normal: vec3f = normalFromDepth(depth, uv, ${this.radius}f);\r\n\r\n                let radiusDepth: f32 = ${this.radius}f / depth;\r\n                var occlusion: f32 = 0.0;\r\n\r\n                var ray: vec3f;\r\n                var hemiRay: vec3f;\r\n                var occlusionDepth: f32;\r\n                var difference: f32;\r\n\r\n                for (var i: i32 = 0; i < 16; i++)\r\n                {\r\n                    ray = radiusDepth * reflect(sampleSphere[i], random);\r\n                    hemiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\n                    occlusionDepth = textureSample(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, clamp(hemiRay.xy, vec2f(0.001, 0.001), vec2f(0.999, 0.999))).r;\r\n                    difference = depth - occlusionDepth;\r\n\r\n                    occlusion += step(${this.fallOff}f, difference) * (1.0 - smoothstep(${this.fallOff}f, ${this.area}f, difference));\r\n                }\r\n\r\n                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);\r\n            }\r\n            `;\r\n        } else {\r\n            functionString = `\r\n            const vec3 sampleSphere[16] = vec3[](\r\n                vec3( 0.5381,  0.1856, -0.4319),\r\n                vec3( 0.1379,  0.2486,  0.4430),\r\n                vec3( 0.3371,  0.5679, -0.0057),\r\n                vec3(-0.6999, -0.0451, -0.0019),\r\n                vec3( 0.0689, -0.1598, -0.8547),\r\n                vec3( 0.0560,  0.0069, -0.1843),\r\n                vec3(-0.0146,  0.1402,  0.0762),\r\n                vec3( 0.0100, -0.1924, -0.0344),\r\n                vec3(-0.3577, -0.5301, -0.4358),\r\n                vec3(-0.3169,  0.1063,  0.0158),\r\n                vec3( 0.0103, -0.5869,  0.0046),\r\n                vec3(-0.0897, -0.4940,  0.3287),\r\n                vec3( 0.7119, -0.0154, -0.0918),\r\n                vec3(-0.0533,  0.0596, -0.5411),\r\n                vec3( 0.0352, -0.0631,  0.5460),\r\n                vec3(-0.4776,  0.2847, -0.0271)\r\n            );\r\n\r\n            float computeOcclusion(vec2 screenSize) {\r\n                vec2 uv = gl_FragCoord.xy / screenSize;\r\n                vec3 random = normalize(textureLod(${this._randomSamplerName}, uv * 4., 0.0).rgb);\r\n                float depth = textureLod(${depthSource.samplerName}, uv, 0.0).r;              \r\n                vec3 position = vec3(uv, depth);\r\n                vec3 normal = normalFromDepth(depth, uv, ${this.radius} );\r\n\r\n                float radiusDepth = ${this.radius} / depth;\r\n                float occlusion = 0.0;\r\n\r\n                vec3 ray;\r\n                vec3 hemiRay;\r\n                float occlusionDepth;\r\n                float difference;\r\n\r\n                for (int i = 0; i < 16; i++)\r\n                {\r\n                    ray = radiusDepth * reflect(sampleSphere[i], random);\r\n                    hemiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\n                    occlusionDepth = texture2D(${depthSource.samplerName}, clamp(hemiRay.xy, vec2(0.001, 0.001), vec2(0.999, 0.999))).r;\r\n                    difference = depth - occlusionDepth;\r\n\r\n                    occlusion += step(${this.fallOff}, difference) * (1.0 - smoothstep(${this.fallOff}, ${this.area}, difference));\r\n                }\r\n\r\n                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);\r\n            }\r\n            `;\r\n        }\r\n\r\n        state._emitFunction(\"computeOcclusion\", functionString, \"// computeOcclusion function\");\r\n\r\n        state.compilationString += state._declareOutput(occlusion) + ` = computeOcclusion(${screenSize.associatedVariableName});`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override dispose(): void {\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            this._randomTexture = null!;\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AmbientOcclusionBlock\", AmbientOcclusionBlock);\r\n"]}