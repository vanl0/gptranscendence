{"version":3,"file":"smartFilterFragmentOutputBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { FragmentOutputBlock } from \"./fragmentOutputBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { ScreenSizeBlock } from \"../Fragment/screenSizeBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport const SfeModeDefine = \"USE_SFE_FRAMEWORK\";\r\n\r\n/**\r\n * Block used to output the final color with Smart Filters structural support.\r\n */\r\nexport class SmartFilterFragmentOutputBlock extends FragmentOutputBlock {\r\n    /**\r\n     * Create a new SmartFilterFragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SmartFilterFragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        super.initialize(state);\r\n\r\n        if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {\r\n            state.sharedData.raiseBuildError(\"SmartFilterFragmentOutputBlock should not be used outside of SFE mode.\");\r\n        }\r\n\r\n        if (state.sharedData.nodeMaterial.shaderLanguage !== ShaderLanguage.GLSL) {\r\n            state.sharedData.raiseBuildError(\"WebGPU is not supported in SmartFilters mode.\");\r\n        }\r\n\r\n        // Annotate uniforms of InputBlocks and bindable blocks with their current values\r\n        if (!state.sharedData.formatConfig.getUniformAnnotation) {\r\n            state.sharedData.formatConfig.getUniformAnnotation = (name: string) => {\r\n                for (const block of state.sharedData.nodeMaterial.attachedBlocks) {\r\n                    if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name) {\r\n                        return this._generateInputBlockAnnotation(block);\r\n                    }\r\n                    if (block instanceof ScreenSizeBlock && block.associatedVariableName === name) {\r\n                        return this._generateScreenSizeBlockAnnotation();\r\n                    }\r\n                }\r\n                return \"\";\r\n            };\r\n        }\r\n\r\n        // Do our best to clean up variable names, as they will be used as display names.\r\n        state.sharedData.formatConfig.formatVariablename = (n: string) => {\r\n            let name = n;\r\n\r\n            const hasUnderscoredPrefix = name.length > 1 && name[1] === \"_\";\r\n            if (hasUnderscoredPrefix) {\r\n                name = name.substring(2);\r\n            }\r\n\r\n            return name.replace(/[^a-zA-Z]+/g, \"\");\r\n        };\r\n    }\r\n\r\n    private _generateInputBlockAnnotation(inputBlock: InputBlock): string {\r\n        const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;\r\n        return `// { \"default\": ${JSON.stringify(value)} }\\n`;\r\n    }\r\n\r\n    private _generateScreenSizeBlockAnnotation(): string {\r\n        return `// { \"autoBind\": \"outputResolution\" }\\n`;\r\n    }\r\n\r\n    private _getMainUvName(state: NodeMaterialBuildState): string {\r\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\r\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\r\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\r\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\r\n            return \"\";\r\n        }\r\n        return screenUv.associatedVariableName;\r\n    }\r\n\r\n    protected override _getOutputString(): string {\r\n        return \"outColor\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const outputString = this._getOutputString();\r\n\r\n        state._injectAtTop = `// { \"smartFilterBlockType\": \"${state.sharedData.nodeMaterial.name}\", \"namespace\": \"Babylon.NME.Exports\" }`;\r\n\r\n        state._customEntryHeader += `#ifdef ${SfeModeDefine}\\n`;\r\n        state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main\\n`;\r\n        state._customEntryHeader += `#else\\n`;\r\n        state._customEntryHeader += `void main(void) {\\n`;\r\n        state._customEntryHeader += `#endif\\n`;\r\n        state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);\\n`;\r\n\r\n        state.compilationString += `\\n#ifndef ${SfeModeDefine}\\n`;\r\n        state.compilationString += `gl_FragColor = ${outputString};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `return ${outputString};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SmartFilterFragmentOutputBlock\", SmartFilterFragmentOutputBlock);\r\n"]}